//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include "Absyn.H"

/********************   Statements    ********************/
Statements::Statements(ListStatement *p1) { liststatement_ = p1; }
Statements::Statements(const Statements & other) {   liststatement_ = other.liststatement_->clone();

}
Statements &Statements::operator=(const Statements & other) {
  Statements tmp(other);
  swap(tmp);
  return *this;
}
void Statements::swap(Statements & other) {
  std::swap(liststatement_, other.liststatement_);

}

Statements::~Statements() { delete(liststatement_); }

void Statements::accept(Visitor *v) { v->visitStatements(this); }
Statements *Statements::clone() const {
  return new Statements(*this);
}

/********************   StatementBlockStat    ********************/
StatementBlockStat::StatementBlockStat(ListStatement *p1) { liststatement_ = p1; }
StatementBlockStat::StatementBlockStat(const StatementBlockStat & other) {   liststatement_ = other.liststatement_->clone();

}
StatementBlockStat &StatementBlockStat::operator=(const StatementBlockStat & other) {
  StatementBlockStat tmp(other);
  swap(tmp);
  return *this;
}
void StatementBlockStat::swap(StatementBlockStat & other) {
  std::swap(liststatement_, other.liststatement_);

}

StatementBlockStat::~StatementBlockStat() { delete(liststatement_); }

void StatementBlockStat::accept(Visitor *v) { v->visitStatementBlockStat(this); }
StatementBlockStat *StatementBlockStat::clone() const {
  return new StatementBlockStat(*this);
}

/********************   ListStatement    ********************/
ListStatement::ListStatement(Statement *p1, ListStatement *p2) { statement_ = p1; liststatement_ = p2; }
ListStatement::ListStatement(const ListStatement & other) {   statement_ = other.statement_->clone();
  liststatement_ = other.liststatement_->clone();

}
ListStatement &ListStatement::operator=(const ListStatement & other) {
  ListStatement tmp(other);
  swap(tmp);
  return *this;
}
void ListStatement::swap(ListStatement & other) {
  std::swap(statement_, other.statement_);
  std::swap(liststatement_, other.liststatement_);

}

ListStatement::~ListStatement() { delete(statement_); delete(liststatement_); }
ListStatement::ListStatement(Statement *p)
{
  statement_ = p;
  liststatement_= 0;
}
ListStatement* ListStatement::reverse()
{
  if (liststatement_ == 0) return this;
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = 0;
    return tmp;
  }
}

ListStatement* ListStatement::reverse(ListStatement* prev)
{
  if (liststatement_ == 0)
  {
    liststatement_ = prev;
    return this;
  }
  else
  {
    ListStatement *tmp = liststatement_->reverse(this);
    liststatement_ = prev;
    return tmp;
  }
}


void ListStatement::accept(Visitor *v) { v->visitListStatement(this); }
ListStatement *ListStatement::clone() const {
  return new ListStatement(*this);
}

/********************   DeclStat    ********************/
DeclStat::DeclStat(Decl *p1) { decl_ = p1; }
DeclStat::DeclStat(const DeclStat & other) {   decl_ = other.decl_->clone();

}
DeclStat &DeclStat::operator=(const DeclStat & other) {
  DeclStat tmp(other);
  swap(tmp);
  return *this;
}
void DeclStat::swap(DeclStat & other) {
  std::swap(decl_, other.decl_);

}

DeclStat::~DeclStat() { delete(decl_); }

void DeclStat::accept(Visitor *v) { v->visitDeclStat(this); }
DeclStat *DeclStat::clone() const {
  return new DeclStat(*this);
}

/********************   ForStatement    ********************/
ForStatement::ForStatement(Ident p1, Exp *p2, StatementBlock *p3) { ident_ = p1; exp_ = p2; statementblock_ = p3; }
ForStatement::ForStatement(const ForStatement & other) {   ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}
ForStatement &ForStatement::operator=(const ForStatement & other) {
  ForStatement tmp(other);
  swap(tmp);
  return *this;
}
void ForStatement::swap(ForStatement & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

ForStatement::~ForStatement() { delete(exp_); delete(statementblock_); }

void ForStatement::accept(Visitor *v) { v->visitForStatement(this); }
ForStatement *ForStatement::clone() const {
  return new ForStatement(*this);
}

/********************   IfStatement    ********************/
IfStatement::IfStatement(Exp *p1, StatementBlock *p2) { exp_ = p1; statementblock_ = p2; }
IfStatement::IfStatement(const IfStatement & other) {   exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}
IfStatement &IfStatement::operator=(const IfStatement & other) {
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}
void IfStatement::swap(IfStatement & other) {
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

IfStatement::~IfStatement() { delete(exp_); delete(statementblock_); }

void IfStatement::accept(Visitor *v) { v->visitIfStatement(this); }
IfStatement *IfStatement::clone() const {
  return new IfStatement(*this);
}

/********************   IfElseStatement    ********************/
IfElseStatement::IfElseStatement(Exp *p1, StatementBlock *p2, ElseBlock *p3) { exp_ = p1; statementblock_ = p2; elseblock_ = p3; }
IfElseStatement::IfElseStatement(const IfElseStatement & other) {   exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}
IfElseStatement &IfElseStatement::operator=(const IfElseStatement & other) {
  IfElseStatement tmp(other);
  swap(tmp);
  return *this;
}
void IfElseStatement::swap(IfElseStatement & other) {
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

IfElseStatement::~IfElseStatement() { delete(exp_); delete(statementblock_); delete(elseblock_); }

void IfElseStatement::accept(Visitor *v) { v->visitIfElseStatement(this); }
IfElseStatement *IfElseStatement::clone() const {
  return new IfElseStatement(*this);
}

/********************   SomeStatement    ********************/
SomeStatement::SomeStatement(Ident p1, Exp *p2, StatementBlock *p3) { ident_ = p1; exp_ = p2; statementblock_ = p3; }
SomeStatement::SomeStatement(const SomeStatement & other) {   ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}
SomeStatement &SomeStatement::operator=(const SomeStatement & other) {
  SomeStatement tmp(other);
  swap(tmp);
  return *this;
}
void SomeStatement::swap(SomeStatement & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

SomeStatement::~SomeStatement() { delete(exp_); delete(statementblock_); }

void SomeStatement::accept(Visitor *v) { v->visitSomeStatement(this); }
SomeStatement *SomeStatement::clone() const {
  return new SomeStatement(*this);
}

/********************   SomeElseStatement    ********************/
SomeElseStatement::SomeElseStatement(Ident p1, Exp *p2, StatementBlock *p3, ElseBlock *p4) { ident_ = p1; exp_ = p2; statementblock_ = p3; elseblock_ = p4; }
SomeElseStatement::SomeElseStatement(const SomeElseStatement & other) {   ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}
SomeElseStatement &SomeElseStatement::operator=(const SomeElseStatement & other) {
  SomeElseStatement tmp(other);
  swap(tmp);
  return *this;
}
void SomeElseStatement::swap(SomeElseStatement & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

SomeElseStatement::~SomeElseStatement() { delete(exp_); delete(statementblock_); delete(elseblock_); }

void SomeElseStatement::accept(Visitor *v) { v->visitSomeElseStatement(this); }
SomeElseStatement *SomeElseStatement::clone() const {
  return new SomeElseStatement(*this);
}

/********************   ConditionalStatement    ********************/
ConditionalStatement::ConditionalStatement(Ident p1, Exp *p2, Exp *p3) { ident_ = p1; exp_1 = p2; exp_2 = p3; }
ConditionalStatement::ConditionalStatement(const ConditionalStatement & other) {   ident_ = other.ident_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
ConditionalStatement &ConditionalStatement::operator=(const ConditionalStatement & other) {
  ConditionalStatement tmp(other);
  swap(tmp);
  return *this;
}
void ConditionalStatement::swap(ConditionalStatement & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ConditionalStatement::~ConditionalStatement() { delete(exp_1); delete(exp_2); }

void ConditionalStatement::accept(Visitor *v) { v->visitConditionalStatement(this); }
ConditionalStatement *ConditionalStatement::clone() const {
  return new ConditionalStatement(*this);
}

/********************   SimpleDecl    ********************/
SimpleDecl::SimpleDecl(Ident p1, Exp *p2) { ident_ = p1; exp_ = p2; }
SimpleDecl::SimpleDecl(const SimpleDecl & other) {   ident_ = other.ident_;
  exp_ = other.exp_->clone();

}
SimpleDecl &SimpleDecl::operator=(const SimpleDecl & other) {
  SimpleDecl tmp(other);
  swap(tmp);
  return *this;
}
void SimpleDecl::swap(SimpleDecl & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

SimpleDecl::~SimpleDecl() { delete(exp_); }

void SimpleDecl::accept(Visitor *v) { v->visitSimpleDecl(this); }
SimpleDecl *SimpleDecl::clone() const {
  return new SimpleDecl(*this);
}

/********************   TypedDecl    ********************/
TypedDecl::TypedDecl(Type *p1, Ident p2, Exp *p3) { type_ = p1; ident_ = p2; exp_ = p3; }
TypedDecl::TypedDecl(const TypedDecl & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;
  exp_ = other.exp_->clone();

}
TypedDecl &TypedDecl::operator=(const TypedDecl & other) {
  TypedDecl tmp(other);
  swap(tmp);
  return *this;
}
void TypedDecl::swap(TypedDecl & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

TypedDecl::~TypedDecl() { delete(type_); delete(exp_); }

void TypedDecl::accept(Visitor *v) { v->visitTypedDecl(this); }
TypedDecl *TypedDecl::clone() const {
  return new TypedDecl(*this);
}

/********************   SimpleDeclWith    ********************/
SimpleDeclWith::SimpleDeclWith(Ident p1, Exp *p2, Exp *p3) { ident_ = p1; exp_1 = p2; exp_2 = p3; }
SimpleDeclWith::SimpleDeclWith(const SimpleDeclWith & other) {   ident_ = other.ident_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
SimpleDeclWith &SimpleDeclWith::operator=(const SimpleDeclWith & other) {
  SimpleDeclWith tmp(other);
  swap(tmp);
  return *this;
}
void SimpleDeclWith::swap(SimpleDeclWith & other) {
  std::swap(ident_, other.ident_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

SimpleDeclWith::~SimpleDeclWith() { delete(exp_1); delete(exp_2); }

void SimpleDeclWith::accept(Visitor *v) { v->visitSimpleDeclWith(this); }
SimpleDeclWith *SimpleDeclWith::clone() const {
  return new SimpleDeclWith(*this);
}

/********************   TypedDeclWith    ********************/
TypedDeclWith::TypedDeclWith(Type *p1, Ident p2, Exp *p3, Exp *p4) { type_ = p1; ident_ = p2; exp_1 = p3; exp_2 = p4; }
TypedDeclWith::TypedDeclWith(const TypedDeclWith & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
TypedDeclWith &TypedDeclWith::operator=(const TypedDeclWith & other) {
  TypedDeclWith tmp(other);
  swap(tmp);
  return *this;
}
void TypedDeclWith::swap(TypedDeclWith & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

TypedDeclWith::~TypedDeclWith() { delete(type_); delete(exp_1); delete(exp_2); }

void TypedDeclWith::accept(Visitor *v) { v->visitTypedDeclWith(this); }
TypedDeclWith *TypedDeclWith::clone() const {
  return new TypedDeclWith(*this);
}

/********************   BareDecl    ********************/
BareDecl::BareDecl(Type *p1, Ident p2) { type_ = p1; ident_ = p2; }
BareDecl::BareDecl(const BareDecl & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;

}
BareDecl &BareDecl::operator=(const BareDecl & other) {
  BareDecl tmp(other);
  swap(tmp);
  return *this;
}
void BareDecl::swap(BareDecl & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

BareDecl::~BareDecl() { delete(type_); }

void BareDecl::accept(Visitor *v) { v->visitBareDecl(this); }
BareDecl *BareDecl::clone() const {
  return new BareDecl(*this);
}

/********************   ElseIfBlock    ********************/
ElseIfBlock::ElseIfBlock(Exp *p1, StatementBlock *p2) { exp_ = p1; statementblock_ = p2; }
ElseIfBlock::ElseIfBlock(const ElseIfBlock & other) {   exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}
ElseIfBlock &ElseIfBlock::operator=(const ElseIfBlock & other) {
  ElseIfBlock tmp(other);
  swap(tmp);
  return *this;
}
void ElseIfBlock::swap(ElseIfBlock & other) {
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

ElseIfBlock::~ElseIfBlock() { delete(exp_); delete(statementblock_); }

void ElseIfBlock::accept(Visitor *v) { v->visitElseIfBlock(this); }
ElseIfBlock *ElseIfBlock::clone() const {
  return new ElseIfBlock(*this);
}

/********************   ElseIf2Block    ********************/
ElseIf2Block::ElseIf2Block(Exp *p1, StatementBlock *p2, ElseBlock *p3) { exp_ = p1; statementblock_ = p2; elseblock_ = p3; }
ElseIf2Block::ElseIf2Block(const ElseIf2Block & other) {   exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}
ElseIf2Block &ElseIf2Block::operator=(const ElseIf2Block & other) {
  ElseIf2Block tmp(other);
  swap(tmp);
  return *this;
}
void ElseIf2Block::swap(ElseIf2Block & other) {
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

ElseIf2Block::~ElseIf2Block() { delete(exp_); delete(statementblock_); delete(elseblock_); }

void ElseIf2Block::accept(Visitor *v) { v->visitElseIf2Block(this); }
ElseIf2Block *ElseIf2Block::clone() const {
  return new ElseIf2Block(*this);
}

/********************   ElseBlockStat    ********************/
ElseBlockStat::ElseBlockStat(StatementBlock *p1) { statementblock_ = p1; }
ElseBlockStat::ElseBlockStat(const ElseBlockStat & other) {   statementblock_ = other.statementblock_->clone();

}
ElseBlockStat &ElseBlockStat::operator=(const ElseBlockStat & other) {
  ElseBlockStat tmp(other);
  swap(tmp);
  return *this;
}
void ElseBlockStat::swap(ElseBlockStat & other) {
  std::swap(statementblock_, other.statementblock_);

}

ElseBlockStat::~ElseBlockStat() { delete(statementblock_); }

void ElseBlockStat::accept(Visitor *v) { v->visitElseBlockStat(this); }
ElseBlockStat *ElseBlockStat::clone() const {
  return new ElseBlockStat(*this);
}

/********************   EFuncDecl    ********************/
EFuncDecl::EFuncDecl(ListArgument *p1, StatementBlock *p2) { listargument_ = p1; statementblock_ = p2; }
EFuncDecl::EFuncDecl(const EFuncDecl & other) {   listargument_ = other.listargument_->clone();
  statementblock_ = other.statementblock_->clone();

}
EFuncDecl &EFuncDecl::operator=(const EFuncDecl & other) {
  EFuncDecl tmp(other);
  swap(tmp);
  return *this;
}
void EFuncDecl::swap(EFuncDecl & other) {
  std::swap(listargument_, other.listargument_);
  std::swap(statementblock_, other.statementblock_);

}

EFuncDecl::~EFuncDecl() { delete(listargument_); delete(statementblock_); }

void EFuncDecl::accept(Visitor *v) { v->visitEFuncDecl(this); }
EFuncDecl *EFuncDecl::clone() const {
  return new EFuncDecl(*this);
}

/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EOr::EOr(const EOr & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EOr &EOr::operator=(const EOr & other) {
  EOr tmp(other);
  swap(tmp);
  return *this;
}
void EOr::swap(EOr & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr() { delete(exp_1); delete(exp_2); }

void EOr::accept(Visitor *v) { v->visitEOr(this); }
EOr *EOr::clone() const {
  return new EOr(*this);
}

/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EAnd::EAnd(const EAnd & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EAnd &EAnd::operator=(const EAnd & other) {
  EAnd tmp(other);
  swap(tmp);
  return *this;
}
void EAnd::swap(EAnd & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd() { delete(exp_1); delete(exp_2); }

void EAnd::accept(Visitor *v) { v->visitEAnd(this); }
EAnd *EAnd::clone() const {
  return new EAnd(*this);
}

/********************   EEquals    ********************/
EEquals::EEquals(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EEquals::EEquals(const EEquals & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EEquals &EEquals::operator=(const EEquals & other) {
  EEquals tmp(other);
  swap(tmp);
  return *this;
}
void EEquals::swap(EEquals & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEquals::~EEquals() { delete(exp_1); delete(exp_2); }

void EEquals::accept(Visitor *v) { v->visitEEquals(this); }
EEquals *EEquals::clone() const {
  return new EEquals(*this);
}

/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
ENEq::ENEq(const ENEq & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
ENEq &ENEq::operator=(const ENEq & other) {
  ENEq tmp(other);
  swap(tmp);
  return *this;
}
void ENEq::swap(ENEq & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq() { delete(exp_1); delete(exp_2); }

void ENEq::accept(Visitor *v) { v->visitENEq(this); }
ENEq *ENEq::clone() const {
  return new ENEq(*this);
}

/********************   ELeq    ********************/
ELeq::ELeq(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
ELeq::ELeq(const ELeq & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
ELeq &ELeq::operator=(const ELeq & other) {
  ELeq tmp(other);
  swap(tmp);
  return *this;
}
void ELeq::swap(ELeq & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELeq::~ELeq() { delete(exp_1); delete(exp_2); }

void ELeq::accept(Visitor *v) { v->visitELeq(this); }
ELeq *ELeq::clone() const {
  return new ELeq(*this);
}

/********************   EGeq    ********************/
EGeq::EGeq(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EGeq::EGeq(const EGeq & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EGeq &EGeq::operator=(const EGeq & other) {
  EGeq tmp(other);
  swap(tmp);
  return *this;
}
void EGeq::swap(EGeq & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGeq::~EGeq() { delete(exp_1); delete(exp_2); }

void EGeq::accept(Visitor *v) { v->visitEGeq(this); }
EGeq *EGeq::clone() const {
  return new EGeq(*this);
}

/********************   ELessThan    ********************/
ELessThan::ELessThan(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
ELessThan::ELessThan(const ELessThan & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
ELessThan &ELessThan::operator=(const ELessThan & other) {
  ELessThan tmp(other);
  swap(tmp);
  return *this;
}
void ELessThan::swap(ELessThan & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELessThan::~ELessThan() { delete(exp_1); delete(exp_2); }

void ELessThan::accept(Visitor *v) { v->visitELessThan(this); }
ELessThan *ELessThan::clone() const {
  return new ELessThan(*this);
}

/********************   EGreaterThan    ********************/
EGreaterThan::EGreaterThan(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EGreaterThan::EGreaterThan(const EGreaterThan & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EGreaterThan &EGreaterThan::operator=(const EGreaterThan & other) {
  EGreaterThan tmp(other);
  swap(tmp);
  return *this;
}
void EGreaterThan::swap(EGreaterThan & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGreaterThan::~EGreaterThan() { delete(exp_1); delete(exp_2); }

void EGreaterThan::accept(Visitor *v) { v->visitEGreaterThan(this); }
EGreaterThan *EGreaterThan::clone() const {
  return new EGreaterThan(*this);
}

/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EAdd::EAdd(const EAdd & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EAdd &EAdd::operator=(const EAdd & other) {
  EAdd tmp(other);
  swap(tmp);
  return *this;
}
void EAdd::swap(EAdd & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd() { delete(exp_1); delete(exp_2); }

void EAdd::accept(Visitor *v) { v->visitEAdd(this); }
EAdd *EAdd::clone() const {
  return new EAdd(*this);
}

/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
ESub::ESub(const ESub & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
ESub &ESub::operator=(const ESub & other) {
  ESub tmp(other);
  swap(tmp);
  return *this;
}
void ESub::swap(ESub & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub() { delete(exp_1); delete(exp_2); }

void ESub::accept(Visitor *v) { v->visitESub(this); }
ESub *ESub::clone() const {
  return new ESub(*this);
}

/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EMul::EMul(const EMul & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EMul &EMul::operator=(const EMul & other) {
  EMul tmp(other);
  swap(tmp);
  return *this;
}
void EMul::swap(EMul & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul() { delete(exp_1); delete(exp_2); }

void EMul::accept(Visitor *v) { v->visitEMul(this); }
EMul *EMul::clone() const {
  return new EMul(*this);
}

/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2) { exp_1 = p1; exp_2 = p2; }
EDiv::EDiv(const EDiv & other) {   exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}
EDiv &EDiv::operator=(const EDiv & other) {
  EDiv tmp(other);
  swap(tmp);
  return *this;
}
void EDiv::swap(EDiv & other) {
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv() { delete(exp_1); delete(exp_2); }

void EDiv::accept(Visitor *v) { v->visitEDiv(this); }
EDiv *EDiv::clone() const {
  return new EDiv(*this);
}

/********************   ENot    ********************/
ENot::ENot(Exp *p1) { exp_ = p1; }
ENot::ENot(const ENot & other) {   exp_ = other.exp_->clone();

}
ENot &ENot::operator=(const ENot & other) {
  ENot tmp(other);
  swap(tmp);
  return *this;
}
void ENot::swap(ENot & other) {
  std::swap(exp_, other.exp_);

}

ENot::~ENot() { delete(exp_); }

void ENot::accept(Visitor *v) { v->visitENot(this); }
ENot *ENot::clone() const {
  return new ENot(*this);
}

/********************   EIdent    ********************/
EIdent::EIdent(Ident p1) { ident_ = p1; }
EIdent::EIdent(const EIdent & other) {   ident_ = other.ident_;

}
EIdent &EIdent::operator=(const EIdent & other) {
  EIdent tmp(other);
  swap(tmp);
  return *this;
}
void EIdent::swap(EIdent & other) {
  std::swap(ident_, other.ident_);

}

EIdent::~EIdent() { }

void EIdent::accept(Visitor *v) { v->visitEIdent(this); }
EIdent *EIdent::clone() const {
  return new EIdent(*this);
}

/********************   EFuncCall    ********************/
EFuncCall::EFuncCall(Ident p1, ListExp *p2) { ident_ = p1; listexp_ = p2; }
EFuncCall::EFuncCall(const EFuncCall & other) {   ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}
EFuncCall &EFuncCall::operator=(const EFuncCall & other) {
  EFuncCall tmp(other);
  swap(tmp);
  return *this;
}
void EFuncCall::swap(EFuncCall & other) {
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

EFuncCall::~EFuncCall() { delete(listexp_); }

void EFuncCall::accept(Visitor *v) { v->visitEFuncCall(this); }
EFuncCall *EFuncCall::clone() const {
  return new EFuncCall(*this);
}

/********************   EInt    ********************/
EInt::EInt(Integer p1) { integer_ = p1; }
EInt::EInt(const EInt & other) {   integer_ = other.integer_;

}
EInt &EInt::operator=(const EInt & other) {
  EInt tmp(other);
  swap(tmp);
  return *this;
}
void EInt::swap(EInt & other) {
  std::swap(integer_, other.integer_);

}

EInt::~EInt() { }

void EInt::accept(Visitor *v) { v->visitEInt(this); }
EInt *EInt::clone() const {
  return new EInt(*this);
}

/********************   EFloat    ********************/
EFloat::EFloat(Double p1) { double_ = p1; }
EFloat::EFloat(const EFloat & other) {   double_ = other.double_;

}
EFloat &EFloat::operator=(const EFloat & other) {
  EFloat tmp(other);
  swap(tmp);
  return *this;
}
void EFloat::swap(EFloat & other) {
  std::swap(double_, other.double_);

}

EFloat::~EFloat() { }

void EFloat::accept(Visitor *v) { v->visitEFloat(this); }
EFloat *EFloat::clone() const {
  return new EFloat(*this);
}

/********************   EString    ********************/
EString::EString(String p1) { string_ = p1; }
EString::EString(const EString & other) {   string_ = other.string_;

}
EString &EString::operator=(const EString & other) {
  EString tmp(other);
  swap(tmp);
  return *this;
}
void EString::swap(EString & other) {
  std::swap(string_, other.string_);

}

EString::~EString() { }

void EString::accept(Visitor *v) { v->visitEString(this); }
EString *EString::clone() const {
  return new EString(*this);
}

/********************   ArgumentDef    ********************/
ArgumentDef::ArgumentDef(Type *p1, Ident p2) { type_ = p1; ident_ = p2; }
ArgumentDef::ArgumentDef(const ArgumentDef & other) {   type_ = other.type_->clone();
  ident_ = other.ident_;

}
ArgumentDef &ArgumentDef::operator=(const ArgumentDef & other) {
  ArgumentDef tmp(other);
  swap(tmp);
  return *this;
}
void ArgumentDef::swap(ArgumentDef & other) {
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

ArgumentDef::~ArgumentDef() { delete(type_); }

void ArgumentDef::accept(Visitor *v) { v->visitArgumentDef(this); }
ArgumentDef *ArgumentDef::clone() const {
  return new ArgumentDef(*this);
}

/********************   ListArgument    ********************/
ListArgument::ListArgument(Argument *p1, ListArgument *p2) { argument_ = p1; listargument_ = p2; }
ListArgument::ListArgument(const ListArgument & other) {   argument_ = other.argument_->clone();
  listargument_ = other.listargument_->clone();

}
ListArgument &ListArgument::operator=(const ListArgument & other) {
  ListArgument tmp(other);
  swap(tmp);
  return *this;
}
void ListArgument::swap(ListArgument & other) {
  std::swap(argument_, other.argument_);
  std::swap(listargument_, other.listargument_);

}

ListArgument::~ListArgument() { delete(argument_); delete(listargument_); }
ListArgument::ListArgument(Argument *p)
{
  argument_ = p;
  listargument_= 0;
}
ListArgument* ListArgument::reverse()
{
  if (listargument_ == 0) return this;
  else
  {
    ListArgument *tmp = listargument_->reverse(this);
    listargument_ = 0;
    return tmp;
  }
}

ListArgument* ListArgument::reverse(ListArgument* prev)
{
  if (listargument_ == 0)
  {
    listargument_ = prev;
    return this;
  }
  else
  {
    ListArgument *tmp = listargument_->reverse(this);
    listargument_ = prev;
    return tmp;
  }
}


void ListArgument::accept(Visitor *v) { v->visitListArgument(this); }
ListArgument *ListArgument::clone() const {
  return new ListArgument(*this);
}

/********************   ListExp    ********************/
ListExp::ListExp(Exp *p1, ListExp *p2) { exp_ = p1; listexp_ = p2; }
ListExp::ListExp(const ListExp & other) {   exp_ = other.exp_->clone();
  listexp_ = other.listexp_->clone();

}
ListExp &ListExp::operator=(const ListExp & other) {
  ListExp tmp(other);
  swap(tmp);
  return *this;
}
void ListExp::swap(ListExp & other) {
  std::swap(exp_, other.exp_);
  std::swap(listexp_, other.listexp_);

}

ListExp::~ListExp() { delete(exp_); delete(listexp_); }
ListExp::ListExp(Exp *p)
{
  exp_ = p;
  listexp_= 0;
}
ListExp* ListExp::reverse()
{
  if (listexp_ == 0) return this;
  else
  {
    ListExp *tmp = listexp_->reverse(this);
    listexp_ = 0;
    return tmp;
  }
}

ListExp* ListExp::reverse(ListExp* prev)
{
  if (listexp_ == 0)
  {
    listexp_ = prev;
    return this;
  }
  else
  {
    ListExp *tmp = listexp_->reverse(this);
    listexp_ = prev;
    return tmp;
  }
}


void ListExp::accept(Visitor *v) { v->visitListExp(this); }
ListExp *ListExp::clone() const {
  return new ListExp(*this);
}

/********************   IntType    ********************/
IntType::IntType() { }
IntType::IntType(const IntType & other) { 
}
IntType &IntType::operator=(const IntType & other) {
  IntType tmp(other);
  swap(tmp);
  return *this;
}
void IntType::swap(IntType & other) {

}

IntType::~IntType() { }

void IntType::accept(Visitor *v) { v->visitIntType(this); }
IntType *IntType::clone() const {
  return new IntType(*this);
}

/********************   FloatType    ********************/
FloatType::FloatType() { }
FloatType::FloatType(const FloatType & other) { 
}
FloatType &FloatType::operator=(const FloatType & other) {
  FloatType tmp(other);
  swap(tmp);
  return *this;
}
void FloatType::swap(FloatType & other) {

}

FloatType::~FloatType() { }

void FloatType::accept(Visitor *v) { v->visitFloatType(this); }
FloatType *FloatType::clone() const {
  return new FloatType(*this);
}

/********************   StringType    ********************/
StringType::StringType() { }
StringType::StringType(const StringType & other) { 
}
StringType &StringType::operator=(const StringType & other) {
  StringType tmp(other);
  swap(tmp);
  return *this;
}
void StringType::swap(StringType & other) {

}

StringType::~StringType() { }

void StringType::accept(Visitor *v) { v->visitStringType(this); }
StringType *StringType::clone() const {
  return new StringType(*this);
}

/********************   BoolType    ********************/
BoolType::BoolType() { }
BoolType::BoolType(const BoolType & other) { 
}
BoolType &BoolType::operator=(const BoolType & other) {
  BoolType tmp(other);
  swap(tmp);
  return *this;
}
void BoolType::swap(BoolType & other) {

}

BoolType::~BoolType() { }

void BoolType::accept(Visitor *v) { v->visitBoolType(this); }
BoolType *BoolType::clone() const {
  return new BoolType(*this);
}

/********************   AnythingType    ********************/
AnythingType::AnythingType() { }
AnythingType::AnythingType(const AnythingType & other) { 
}
AnythingType &AnythingType::operator=(const AnythingType & other) {
  AnythingType tmp(other);
  swap(tmp);
  return *this;
}
void AnythingType::swap(AnythingType & other) {

}

AnythingType::~AnythingType() { }

void AnythingType::accept(Visitor *v) { v->visitAnythingType(this); }
AnythingType *AnythingType::clone() const {
  return new AnythingType(*this);
}

/********************   NothingType    ********************/
NothingType::NothingType() { }
NothingType::NothingType(const NothingType & other) { 
}
NothingType &NothingType::operator=(const NothingType & other) {
  NothingType tmp(other);
  swap(tmp);
  return *this;
}
void NothingType::swap(NothingType & other) {

}

NothingType::~NothingType() { }

void NothingType::accept(Visitor *v) { v->visitNothingType(this); }
NothingType *NothingType::clone() const {
  return new NothingType(*this);
}

/********************   UnitType    ********************/
UnitType::UnitType() { }
UnitType::UnitType(const UnitType & other) { 
}
UnitType &UnitType::operator=(const UnitType & other) {
  UnitType tmp(other);
  swap(tmp);
  return *this;
}
void UnitType::swap(UnitType & other) {

}

UnitType::~UnitType() { }

void UnitType::accept(Visitor *v) { v->visitUnitType(this); }
UnitType *UnitType::clone() const {
  return new UnitType(*this);
}

/********************   VectorType    ********************/
VectorType::VectorType(Type *p1) { type_ = p1; }
VectorType::VectorType(const VectorType & other) {   type_ = other.type_->clone();

}
VectorType &VectorType::operator=(const VectorType & other) {
  VectorType tmp(other);
  swap(tmp);
  return *this;
}
void VectorType::swap(VectorType & other) {
  std::swap(type_, other.type_);

}

VectorType::~VectorType() { delete(type_); }

void VectorType::accept(Visitor *v) { v->visitVectorType(this); }
VectorType *VectorType::clone() const {
  return new VectorType(*this);
}


