#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class StatementBlock;
class Statement;
class Decl;
class ElseBlock;
class Exp;
class Argument;
class Type;
class SetTypeElem;
class Statements;
class StatementBlockStat;
class DeclStat;
class SimpleDecl;
class TypedDecl;
class SimpleDeclWith;
class TypedDeclWith;
class BareDecl;
class EFuncDecl;
class EFuncDeclWithType;
class ForStatement;
class IfStatement;
class IfElseStatement;
class ElseIfBlock;
class ElseIf2Block;
class ElseBlockStat;
class ElseFailStat;
class SomeStatement;
class SomeElseStatement;
class ConditionalStatement;
class ExpAsStatement;
class EOr;
class EAnd;
class EEquals;
class ENEq;
class ELeq;
class EGeq;
class ELessThan;
class EGreaterThan;
class EAdd;
class ESub;
class EMul;
class EDiv;
class ENot;
class EIdent;
class EVector;
class EFuncCall;
class ArgumentDef;
class EInt;
class EFloat;
class EString;
class EType;
class VectorType;
class RangeType;
class SetType;
class EIntSTE;
class EFloatSTE;
class EStringSTE;
class ListStatement;
class ListArgument;
class ListExp;
class ListSetTypeElem;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitStatementBlock(StatementBlock *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitElseBlock(ElseBlock *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitArgument(Argument *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitSetTypeElem(SetTypeElem *p) = 0;
  virtual void visitStatements(Statements *p) = 0;
  virtual void visitStatementBlockStat(StatementBlockStat *p) = 0;
  virtual void visitDeclStat(DeclStat *p) = 0;
  virtual void visitSimpleDecl(SimpleDecl *p) = 0;
  virtual void visitTypedDecl(TypedDecl *p) = 0;
  virtual void visitSimpleDeclWith(SimpleDeclWith *p) = 0;
  virtual void visitTypedDeclWith(TypedDeclWith *p) = 0;
  virtual void visitBareDecl(BareDecl *p) = 0;
  virtual void visitEFuncDecl(EFuncDecl *p) = 0;
  virtual void visitEFuncDeclWithType(EFuncDeclWithType *p) = 0;
  virtual void visitForStatement(ForStatement *p) = 0;
  virtual void visitIfStatement(IfStatement *p) = 0;
  virtual void visitIfElseStatement(IfElseStatement *p) = 0;
  virtual void visitElseIfBlock(ElseIfBlock *p) = 0;
  virtual void visitElseIf2Block(ElseIf2Block *p) = 0;
  virtual void visitElseBlockStat(ElseBlockStat *p) = 0;
  virtual void visitElseFailStat(ElseFailStat *p) = 0;
  virtual void visitSomeStatement(SomeStatement *p) = 0;
  virtual void visitSomeElseStatement(SomeElseStatement *p) = 0;
  virtual void visitConditionalStatement(ConditionalStatement *p) = 0;
  virtual void visitExpAsStatement(ExpAsStatement *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEEquals(EEquals *p) = 0;
  virtual void visitENEq(ENEq *p) = 0;
  virtual void visitELeq(ELeq *p) = 0;
  virtual void visitEGeq(EGeq *p) = 0;
  virtual void visitELessThan(ELessThan *p) = 0;
  virtual void visitEGreaterThan(EGreaterThan *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEDiv(EDiv *p) = 0;
  virtual void visitENot(ENot *p) = 0;
  virtual void visitEIdent(EIdent *p) = 0;
  virtual void visitEVector(EVector *p) = 0;
  virtual void visitEFuncCall(EFuncCall *p) = 0;
  virtual void visitArgumentDef(ArgumentDef *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEFloat(EFloat *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitEType(EType *p) = 0;
  virtual void visitVectorType(VectorType *p) = 0;
  virtual void visitRangeType(RangeType *p) = 0;
  virtual void visitSetType(SetType *p) = 0;
  virtual void visitEIntSTE(EIntSTE *p) = 0;
  virtual void visitEFloatSTE(EFloatSTE *p) = 0;
  virtual void visitEStringSTE(EStringSTE *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListArgument(ListArgument *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;
  virtual void visitListSetTypeElem(ListSetTypeElem *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number;
};

class StatementBlock : public Visitable
{
public:
  virtual StatementBlock *clone() const = 0;
  int line_number;
};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;
  int line_number;
};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;
  int line_number;
};

class ElseBlock : public Visitable
{
public:
  virtual ElseBlock *clone() const = 0;
  int line_number;
};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;
  int line_number;
};

class Argument : public Visitable
{
public:
  virtual Argument *clone() const = 0;
  int line_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number;
};

class SetTypeElem : public Visitable
{
public:
  virtual SetTypeElem *clone() const = 0;
  int line_number;
};



class Statements : public Program
{
public:
  ListStatement *liststatement_;

  Statements(const Statements &);
  Statements &operator=(const Statements &);
  Statements(ListStatement *p1);
  ~Statements();
  virtual void accept(Visitor *v);
  virtual Statements *clone() const;
  void swap(Statements &);
};

class StatementBlockStat : public StatementBlock
{
public:
  ListStatement *liststatement_;

  StatementBlockStat(const StatementBlockStat &);
  StatementBlockStat &operator=(const StatementBlockStat &);
  StatementBlockStat(ListStatement *p1);
  ~StatementBlockStat();
  virtual void accept(Visitor *v);
  virtual StatementBlockStat *clone() const;
  void swap(StatementBlockStat &);
};

class DeclStat : public Statement
{
public:
  Decl *decl_;

  DeclStat(const DeclStat &);
  DeclStat &operator=(const DeclStat &);
  DeclStat(Decl *p1);
  ~DeclStat();
  virtual void accept(Visitor *v);
  virtual DeclStat *clone() const;
  void swap(DeclStat &);
};

class ForStatement : public Statement
{
public:
  Ident ident_;
  Exp *exp_;
  StatementBlock *statementblock_;

  ForStatement(const ForStatement &);
  ForStatement &operator=(const ForStatement &);
  ForStatement(Ident p1, Exp *p2, StatementBlock *p3);
  ~ForStatement();
  virtual void accept(Visitor *v);
  virtual ForStatement *clone() const;
  void swap(ForStatement &);
};

class IfStatement : public Statement
{
public:
  Exp *exp_;
  StatementBlock *statementblock_;

  IfStatement(const IfStatement &);
  IfStatement &operator=(const IfStatement &);
  IfStatement(Exp *p1, StatementBlock *p2);
  ~IfStatement();
  virtual void accept(Visitor *v);
  virtual IfStatement *clone() const;
  void swap(IfStatement &);
};

class IfElseStatement : public Statement
{
public:
  Exp *exp_;
  StatementBlock *statementblock_;
  ElseBlock *elseblock_;

  IfElseStatement(const IfElseStatement &);
  IfElseStatement &operator=(const IfElseStatement &);
  IfElseStatement(Exp *p1, StatementBlock *p2, ElseBlock *p3);
  ~IfElseStatement();
  virtual void accept(Visitor *v);
  virtual IfElseStatement *clone() const;
  void swap(IfElseStatement &);
};

class SomeStatement : public Statement
{
public:
  Ident ident_;
  Exp *exp_;
  StatementBlock *statementblock_;

  SomeStatement(const SomeStatement &);
  SomeStatement &operator=(const SomeStatement &);
  SomeStatement(Ident p1, Exp *p2, StatementBlock *p3);
  ~SomeStatement();
  virtual void accept(Visitor *v);
  virtual SomeStatement *clone() const;
  void swap(SomeStatement &);
};

class SomeElseStatement : public Statement
{
public:
  Ident ident_;
  Exp *exp_;
  StatementBlock *statementblock_;
  ElseBlock *elseblock_;

  SomeElseStatement(const SomeElseStatement &);
  SomeElseStatement &operator=(const SomeElseStatement &);
  SomeElseStatement(Ident p1, Exp *p2, StatementBlock *p3, ElseBlock *p4);
  ~SomeElseStatement();
  virtual void accept(Visitor *v);
  virtual SomeElseStatement *clone() const;
  void swap(SomeElseStatement &);
};

class ConditionalStatement : public Statement
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ConditionalStatement(const ConditionalStatement &);
  ConditionalStatement &operator=(const ConditionalStatement &);
  ConditionalStatement(Exp *p1, Exp *p2);
  ~ConditionalStatement();
  virtual void accept(Visitor *v);
  virtual ConditionalStatement *clone() const;
  void swap(ConditionalStatement &);
};

class ExpAsStatement : public Statement
{
public:
  Exp *exp_;

  ExpAsStatement(const ExpAsStatement &);
  ExpAsStatement &operator=(const ExpAsStatement &);
  ExpAsStatement(Exp *p1);
  ~ExpAsStatement();
  virtual void accept(Visitor *v);
  virtual ExpAsStatement *clone() const;
  void swap(ExpAsStatement &);
};

class SimpleDecl : public Decl
{
public:
  Ident ident_;
  Exp *exp_;

  SimpleDecl(const SimpleDecl &);
  SimpleDecl &operator=(const SimpleDecl &);
  SimpleDecl(Ident p1, Exp *p2);
  ~SimpleDecl();
  virtual void accept(Visitor *v);
  virtual SimpleDecl *clone() const;
  void swap(SimpleDecl &);
};

class TypedDecl : public Decl
{
public:
  Type *type_;
  Ident ident_;
  Exp *exp_;

  TypedDecl(const TypedDecl &);
  TypedDecl &operator=(const TypedDecl &);
  TypedDecl(Type *p1, Ident p2, Exp *p3);
  ~TypedDecl();
  virtual void accept(Visitor *v);
  virtual TypedDecl *clone() const;
  void swap(TypedDecl &);
};

class SimpleDeclWith : public Decl
{
public:
  Ident ident_;
  Exp *exp_1;
  Exp *exp_2;

  SimpleDeclWith(const SimpleDeclWith &);
  SimpleDeclWith &operator=(const SimpleDeclWith &);
  SimpleDeclWith(Ident p1, Exp *p2, Exp *p3);
  ~SimpleDeclWith();
  virtual void accept(Visitor *v);
  virtual SimpleDeclWith *clone() const;
  void swap(SimpleDeclWith &);
};

class TypedDeclWith : public Decl
{
public:
  Type *type_;
  Ident ident_;
  Exp *exp_1;
  Exp *exp_2;

  TypedDeclWith(const TypedDeclWith &);
  TypedDeclWith &operator=(const TypedDeclWith &);
  TypedDeclWith(Type *p1, Ident p2, Exp *p3, Exp *p4);
  ~TypedDeclWith();
  virtual void accept(Visitor *v);
  virtual TypedDeclWith *clone() const;
  void swap(TypedDeclWith &);
};

class BareDecl : public Decl
{
public:
  Type *type_;
  Ident ident_;

  BareDecl(const BareDecl &);
  BareDecl &operator=(const BareDecl &);
  BareDecl(Type *p1, Ident p2);
  ~BareDecl();
  virtual void accept(Visitor *v);
  virtual BareDecl *clone() const;
  void swap(BareDecl &);
};

class EFuncDecl : public Decl
{
public:
  Ident ident_;
  ListArgument *listargument_;
  StatementBlock *statementblock_;

  EFuncDecl(const EFuncDecl &);
  EFuncDecl &operator=(const EFuncDecl &);
  EFuncDecl(Ident p1, ListArgument *p2, StatementBlock *p3);
  ~EFuncDecl();
  virtual void accept(Visitor *v);
  virtual EFuncDecl *clone() const;
  void swap(EFuncDecl &);
};

class EFuncDeclWithType : public Decl
{
public:
  Type *type_;
  Ident ident_;
  ListArgument *listargument_;
  StatementBlock *statementblock_;

  EFuncDeclWithType(const EFuncDeclWithType &);
  EFuncDeclWithType &operator=(const EFuncDeclWithType &);
  EFuncDeclWithType(Type *p1, Ident p2, ListArgument *p3, StatementBlock *p4);
  ~EFuncDeclWithType();
  virtual void accept(Visitor *v);
  virtual EFuncDeclWithType *clone() const;
  void swap(EFuncDeclWithType &);
};

class ElseIfBlock : public ElseBlock
{
public:
  Exp *exp_;
  StatementBlock *statementblock_;

  ElseIfBlock(const ElseIfBlock &);
  ElseIfBlock &operator=(const ElseIfBlock &);
  ElseIfBlock(Exp *p1, StatementBlock *p2);
  ~ElseIfBlock();
  virtual void accept(Visitor *v);
  virtual ElseIfBlock *clone() const;
  void swap(ElseIfBlock &);
};

class ElseIf2Block : public ElseBlock
{
public:
  Exp *exp_;
  StatementBlock *statementblock_;
  ElseBlock *elseblock_;

  ElseIf2Block(const ElseIf2Block &);
  ElseIf2Block &operator=(const ElseIf2Block &);
  ElseIf2Block(Exp *p1, StatementBlock *p2, ElseBlock *p3);
  ~ElseIf2Block();
  virtual void accept(Visitor *v);
  virtual ElseIf2Block *clone() const;
  void swap(ElseIf2Block &);
};

class ElseBlockStat : public ElseBlock
{
public:
  StatementBlock *statementblock_;

  ElseBlockStat(const ElseBlockStat &);
  ElseBlockStat &operator=(const ElseBlockStat &);
  ElseBlockStat(StatementBlock *p1);
  ~ElseBlockStat();
  virtual void accept(Visitor *v);
  virtual ElseBlockStat *clone() const;
  void swap(ElseBlockStat &);
};

class ElseFailStat : public ElseBlock
{
public:

  ElseFailStat(const ElseFailStat &);
  ElseFailStat &operator=(const ElseFailStat &);
  ElseFailStat();
  ~ElseFailStat();
  virtual void accept(Visitor *v);
  virtual ElseFailStat *clone() const;
  void swap(ElseFailStat &);
};

class EOr : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Exp *p1, Exp *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class EAnd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Exp *p1, Exp *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EEquals : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EEquals(const EEquals &);
  EEquals &operator=(const EEquals &);
  EEquals(Exp *p1, Exp *p2);
  ~EEquals();
  virtual void accept(Visitor *v);
  virtual EEquals *clone() const;
  void swap(EEquals &);
};

class ENEq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ENEq(const ENEq &);
  ENEq &operator=(const ENEq &);
  ENEq(Exp *p1, Exp *p2);
  ~ENEq();
  virtual void accept(Visitor *v);
  virtual ENEq *clone() const;
  void swap(ENEq &);
};

class ELeq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELeq(const ELeq &);
  ELeq &operator=(const ELeq &);
  ELeq(Exp *p1, Exp *p2);
  ~ELeq();
  virtual void accept(Visitor *v);
  virtual ELeq *clone() const;
  void swap(ELeq &);
};

class EGeq : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGeq(const EGeq &);
  EGeq &operator=(const EGeq &);
  EGeq(Exp *p1, Exp *p2);
  ~EGeq();
  virtual void accept(Visitor *v);
  virtual EGeq *clone() const;
  void swap(EGeq &);
};

class ELessThan : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELessThan(const ELessThan &);
  ELessThan &operator=(const ELessThan &);
  ELessThan(Exp *p1, Exp *p2);
  ~ELessThan();
  virtual void accept(Visitor *v);
  virtual ELessThan *clone() const;
  void swap(ELessThan &);
};

class EGreaterThan : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGreaterThan(const EGreaterThan &);
  EGreaterThan &operator=(const EGreaterThan &);
  EGreaterThan(Exp *p1, Exp *p2);
  ~EGreaterThan();
  virtual void accept(Visitor *v);
  virtual EGreaterThan *clone() const;
  void swap(EGreaterThan &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EDiv : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EDiv(const EDiv &);
  EDiv &operator=(const EDiv &);
  EDiv(Exp *p1, Exp *p2);
  ~EDiv();
  virtual void accept(Visitor *v);
  virtual EDiv *clone() const;
  void swap(EDiv &);
};

class ENot : public Exp
{
public:
  Exp *exp_;

  ENot(const ENot &);
  ENot &operator=(const ENot &);
  ENot(Exp *p1);
  ~ENot();
  virtual void accept(Visitor *v);
  virtual ENot *clone() const;
  void swap(ENot &);
};

class EIdent : public Exp
{
public:
  Ident ident_;

  EIdent(const EIdent &);
  EIdent &operator=(const EIdent &);
  EIdent(Ident p1);
  ~EIdent();
  virtual void accept(Visitor *v);
  virtual EIdent *clone() const;
  void swap(EIdent &);
};

class EVector : public Exp
{
public:
  Ident ident_;
  ListExp *listexp_;

  EVector(const EVector &);
  EVector &operator=(const EVector &);
  EVector(Ident p1, ListExp *p2);
  ~EVector();
  virtual void accept(Visitor *v);
  virtual EVector *clone() const;
  void swap(EVector &);
};

class EFuncCall : public Exp
{
public:
  Ident ident_;
  ListExp *listexp_;

  EFuncCall(const EFuncCall &);
  EFuncCall &operator=(const EFuncCall &);
  EFuncCall(Ident p1, ListExp *p2);
  ~EFuncCall();
  virtual void accept(Visitor *v);
  virtual EFuncCall *clone() const;
  void swap(EFuncCall &);
};

class EInt : public Exp
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EFloat : public Exp
{
public:
  Double double_;

  EFloat(const EFloat &);
  EFloat &operator=(const EFloat &);
  EFloat(Double p1);
  ~EFloat();
  virtual void accept(Visitor *v);
  virtual EFloat *clone() const;
  void swap(EFloat &);
};

class EString : public Exp
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class ArgumentDef : public Argument
{
public:
  Type *type_;
  Ident ident_;

  ArgumentDef(const ArgumentDef &);
  ArgumentDef &operator=(const ArgumentDef &);
  ArgumentDef(Type *p1, Ident p2);
  ~ArgumentDef();
  virtual void accept(Visitor *v);
  virtual ArgumentDef *clone() const;
  void swap(ArgumentDef &);
};

class EType : public Type
{
public:
  Ident ident_;

  EType(const EType &);
  EType &operator=(const EType &);
  EType(Ident p1);
  ~EType();
  virtual void accept(Visitor *v);
  virtual EType *clone() const;
  void swap(EType &);
};

class VectorType : public Type
{
public:
  Type *type_1;
  Type *type_2;

  VectorType(const VectorType &);
  VectorType &operator=(const VectorType &);
  VectorType(Type *p1, Type *p2);
  ~VectorType();
  virtual void accept(Visitor *v);
  virtual VectorType *clone() const;
  void swap(VectorType &);
};

class RangeType : public Type
{
public:
  Integer integer_1;
  Integer integer_2;

  RangeType(const RangeType &);
  RangeType &operator=(const RangeType &);
  RangeType(Integer p1, Integer p2);
  ~RangeType();
  virtual void accept(Visitor *v);
  virtual RangeType *clone() const;
  void swap(RangeType &);
};

class SetType : public Type
{
public:
  ListSetTypeElem *listsettypeelem_;

  SetType(const SetType &);
  SetType &operator=(const SetType &);
  SetType(ListSetTypeElem *p1);
  ~SetType();
  virtual void accept(Visitor *v);
  virtual SetType *clone() const;
  void swap(SetType &);
};

class EIntSTE : public SetTypeElem
{
public:
  Integer integer_;

  EIntSTE(const EIntSTE &);
  EIntSTE &operator=(const EIntSTE &);
  EIntSTE(Integer p1);
  ~EIntSTE();
  virtual void accept(Visitor *v);
  virtual EIntSTE *clone() const;
  void swap(EIntSTE &);
};

class EFloatSTE : public SetTypeElem
{
public:
  Double double_;

  EFloatSTE(const EFloatSTE &);
  EFloatSTE &operator=(const EFloatSTE &);
  EFloatSTE(Double p1);
  ~EFloatSTE();
  virtual void accept(Visitor *v);
  virtual EFloatSTE *clone() const;
  void swap(EFloatSTE &);
};

class EStringSTE : public SetTypeElem
{
public:
  String string_;

  EStringSTE(const EStringSTE &);
  EStringSTE &operator=(const EStringSTE &);
  EStringSTE(String p1);
  ~EStringSTE();
  virtual void accept(Visitor *v);
  virtual EStringSTE *clone() const;
  void swap(EStringSTE &);
};



class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};

class ListArgument : public Visitable, public std::vector<Argument*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArgument *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};

class ListSetTypeElem : public Visitable, public std::vector<SetTypeElem*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListSetTypeElem *clone() const;
};



#endif
