//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"
/********************   Statements    ********************/
Statements::Statements(ListStatement *p1)
{
  liststatement_ = p1;

}

Statements::Statements(const Statements & other)
{
  liststatement_ = other.liststatement_->clone();

}

Statements &Statements::operator=(const Statements & other)
{
  Statements tmp(other);
  swap(tmp);
  return *this;
}

void Statements::swap(Statements & other)
{
  std::swap(liststatement_, other.liststatement_);

}

Statements::~Statements()
{
  delete(liststatement_);

}

void Statements::accept(Visitor *v)
{
  v->visitStatements(this);
}

Statements *Statements::clone() const
{
  return new Statements(*this);
}



/********************   StatementBlockStat    ********************/
StatementBlockStat::StatementBlockStat(ListStatement *p1)
{
  liststatement_ = p1;

}

StatementBlockStat::StatementBlockStat(const StatementBlockStat & other)
{
  liststatement_ = other.liststatement_->clone();

}

StatementBlockStat &StatementBlockStat::operator=(const StatementBlockStat & other)
{
  StatementBlockStat tmp(other);
  swap(tmp);
  return *this;
}

void StatementBlockStat::swap(StatementBlockStat & other)
{
  std::swap(liststatement_, other.liststatement_);

}

StatementBlockStat::~StatementBlockStat()
{
  delete(liststatement_);

}

void StatementBlockStat::accept(Visitor *v)
{
  v->visitStatementBlockStat(this);
}

StatementBlockStat *StatementBlockStat::clone() const
{
  return new StatementBlockStat(*this);
}



/********************   DeclStat    ********************/
DeclStat::DeclStat(Decl *p1)
{
  decl_ = p1;

}

DeclStat::DeclStat(const DeclStat & other)
{
  decl_ = other.decl_->clone();

}

DeclStat &DeclStat::operator=(const DeclStat & other)
{
  DeclStat tmp(other);
  swap(tmp);
  return *this;
}

void DeclStat::swap(DeclStat & other)
{
  std::swap(decl_, other.decl_);

}

DeclStat::~DeclStat()
{
  delete(decl_);

}

void DeclStat::accept(Visitor *v)
{
  v->visitDeclStat(this);
}

DeclStat *DeclStat::clone() const
{
  return new DeclStat(*this);
}



/********************   ForStatement    ********************/
ForStatement::ForStatement(Ident p1, Exp *p2, StatementBlock *p3)
{
  ident_ = p1;
  exp_ = p2;
  statementblock_ = p3;

}

ForStatement::ForStatement(const ForStatement & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}

ForStatement &ForStatement::operator=(const ForStatement & other)
{
  ForStatement tmp(other);
  swap(tmp);
  return *this;
}

void ForStatement::swap(ForStatement & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

ForStatement::~ForStatement()
{
  delete(exp_);
  delete(statementblock_);

}

void ForStatement::accept(Visitor *v)
{
  v->visitForStatement(this);
}

ForStatement *ForStatement::clone() const
{
  return new ForStatement(*this);
}



/********************   IfStatement    ********************/
IfStatement::IfStatement(Exp *p1, StatementBlock *p2)
{
  exp_ = p1;
  statementblock_ = p2;

}

IfStatement::IfStatement(const IfStatement & other)
{
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}

IfStatement &IfStatement::operator=(const IfStatement & other)
{
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfStatement::swap(IfStatement & other)
{
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

IfStatement::~IfStatement()
{
  delete(exp_);
  delete(statementblock_);

}

void IfStatement::accept(Visitor *v)
{
  v->visitIfStatement(this);
}

IfStatement *IfStatement::clone() const
{
  return new IfStatement(*this);
}



/********************   IfElseStatement    ********************/
IfElseStatement::IfElseStatement(Exp *p1, StatementBlock *p2, ElseBlock *p3)
{
  exp_ = p1;
  statementblock_ = p2;
  elseblock_ = p3;

}

IfElseStatement::IfElseStatement(const IfElseStatement & other)
{
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}

IfElseStatement &IfElseStatement::operator=(const IfElseStatement & other)
{
  IfElseStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfElseStatement::swap(IfElseStatement & other)
{
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

IfElseStatement::~IfElseStatement()
{
  delete(exp_);
  delete(statementblock_);
  delete(elseblock_);

}

void IfElseStatement::accept(Visitor *v)
{
  v->visitIfElseStatement(this);
}

IfElseStatement *IfElseStatement::clone() const
{
  return new IfElseStatement(*this);
}



/********************   SomeStatement    ********************/
SomeStatement::SomeStatement(Ident p1, Exp *p2, StatementBlock *p3)
{
  ident_ = p1;
  exp_ = p2;
  statementblock_ = p3;

}

SomeStatement::SomeStatement(const SomeStatement & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}

SomeStatement &SomeStatement::operator=(const SomeStatement & other)
{
  SomeStatement tmp(other);
  swap(tmp);
  return *this;
}

void SomeStatement::swap(SomeStatement & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

SomeStatement::~SomeStatement()
{
  delete(exp_);
  delete(statementblock_);

}

void SomeStatement::accept(Visitor *v)
{
  v->visitSomeStatement(this);
}

SomeStatement *SomeStatement::clone() const
{
  return new SomeStatement(*this);
}



/********************   SomeElseStatement    ********************/
SomeElseStatement::SomeElseStatement(Ident p1, Exp *p2, StatementBlock *p3, ElseBlock *p4)
{
  ident_ = p1;
  exp_ = p2;
  statementblock_ = p3;
  elseblock_ = p4;

}

SomeElseStatement::SomeElseStatement(const SomeElseStatement & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}

SomeElseStatement &SomeElseStatement::operator=(const SomeElseStatement & other)
{
  SomeElseStatement tmp(other);
  swap(tmp);
  return *this;
}

void SomeElseStatement::swap(SomeElseStatement & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

SomeElseStatement::~SomeElseStatement()
{
  delete(exp_);
  delete(statementblock_);
  delete(elseblock_);

}

void SomeElseStatement::accept(Visitor *v)
{
  v->visitSomeElseStatement(this);
}

SomeElseStatement *SomeElseStatement::clone() const
{
  return new SomeElseStatement(*this);
}



/********************   ConditionalStatement    ********************/
ConditionalStatement::ConditionalStatement(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ConditionalStatement::ConditionalStatement(const ConditionalStatement & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ConditionalStatement &ConditionalStatement::operator=(const ConditionalStatement & other)
{
  ConditionalStatement tmp(other);
  swap(tmp);
  return *this;
}

void ConditionalStatement::swap(ConditionalStatement & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ConditionalStatement::~ConditionalStatement()
{
  delete(exp_1);
  delete(exp_2);

}

void ConditionalStatement::accept(Visitor *v)
{
  v->visitConditionalStatement(this);
}

ConditionalStatement *ConditionalStatement::clone() const
{
  return new ConditionalStatement(*this);
}



/********************   ExpAsStatement    ********************/
ExpAsStatement::ExpAsStatement(Exp *p1)
{
  exp_ = p1;

}

ExpAsStatement::ExpAsStatement(const ExpAsStatement & other)
{
  exp_ = other.exp_->clone();

}

ExpAsStatement &ExpAsStatement::operator=(const ExpAsStatement & other)
{
  ExpAsStatement tmp(other);
  swap(tmp);
  return *this;
}

void ExpAsStatement::swap(ExpAsStatement & other)
{
  std::swap(exp_, other.exp_);

}

ExpAsStatement::~ExpAsStatement()
{
  delete(exp_);

}

void ExpAsStatement::accept(Visitor *v)
{
  v->visitExpAsStatement(this);
}

ExpAsStatement *ExpAsStatement::clone() const
{
  return new ExpAsStatement(*this);
}



/********************   SimpleDecl    ********************/
SimpleDecl::SimpleDecl(Ident p1, Exp *p2)
{
  ident_ = p1;
  exp_ = p2;

}

SimpleDecl::SimpleDecl(const SimpleDecl & other)
{
  ident_ = other.ident_;
  exp_ = other.exp_->clone();

}

SimpleDecl &SimpleDecl::operator=(const SimpleDecl & other)
{
  SimpleDecl tmp(other);
  swap(tmp);
  return *this;
}

void SimpleDecl::swap(SimpleDecl & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

SimpleDecl::~SimpleDecl()
{
  delete(exp_);

}

void SimpleDecl::accept(Visitor *v)
{
  v->visitSimpleDecl(this);
}

SimpleDecl *SimpleDecl::clone() const
{
  return new SimpleDecl(*this);
}



/********************   TypedDecl    ********************/
TypedDecl::TypedDecl(Type *p1, Ident p2, Exp *p3)
{
  type_ = p1;
  ident_ = p2;
  exp_ = p3;

}

TypedDecl::TypedDecl(const TypedDecl & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  exp_ = other.exp_->clone();

}

TypedDecl &TypedDecl::operator=(const TypedDecl & other)
{
  TypedDecl tmp(other);
  swap(tmp);
  return *this;
}

void TypedDecl::swap(TypedDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(exp_, other.exp_);

}

TypedDecl::~TypedDecl()
{
  delete(type_);
  delete(exp_);

}

void TypedDecl::accept(Visitor *v)
{
  v->visitTypedDecl(this);
}

TypedDecl *TypedDecl::clone() const
{
  return new TypedDecl(*this);
}



/********************   SimpleDeclWith    ********************/
SimpleDeclWith::SimpleDeclWith(Ident p1, Exp *p2, Exp *p3)
{
  ident_ = p1;
  exp_1 = p2;
  exp_2 = p3;

}

SimpleDeclWith::SimpleDeclWith(const SimpleDeclWith & other)
{
  ident_ = other.ident_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

SimpleDeclWith &SimpleDeclWith::operator=(const SimpleDeclWith & other)
{
  SimpleDeclWith tmp(other);
  swap(tmp);
  return *this;
}

void SimpleDeclWith::swap(SimpleDeclWith & other)
{
  std::swap(ident_, other.ident_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

SimpleDeclWith::~SimpleDeclWith()
{
  delete(exp_1);
  delete(exp_2);

}

void SimpleDeclWith::accept(Visitor *v)
{
  v->visitSimpleDeclWith(this);
}

SimpleDeclWith *SimpleDeclWith::clone() const
{
  return new SimpleDeclWith(*this);
}



/********************   TypedDeclWith    ********************/
TypedDeclWith::TypedDeclWith(Type *p1, Ident p2, Exp *p3, Exp *p4)
{
  type_ = p1;
  ident_ = p2;
  exp_1 = p3;
  exp_2 = p4;

}

TypedDeclWith::TypedDeclWith(const TypedDeclWith & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

TypedDeclWith &TypedDeclWith::operator=(const TypedDeclWith & other)
{
  TypedDeclWith tmp(other);
  swap(tmp);
  return *this;
}

void TypedDeclWith::swap(TypedDeclWith & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

TypedDeclWith::~TypedDeclWith()
{
  delete(type_);
  delete(exp_1);
  delete(exp_2);

}

void TypedDeclWith::accept(Visitor *v)
{
  v->visitTypedDeclWith(this);
}

TypedDeclWith *TypedDeclWith::clone() const
{
  return new TypedDeclWith(*this);
}



/********************   BareDecl    ********************/
BareDecl::BareDecl(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

BareDecl::BareDecl(const BareDecl & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

BareDecl &BareDecl::operator=(const BareDecl & other)
{
  BareDecl tmp(other);
  swap(tmp);
  return *this;
}

void BareDecl::swap(BareDecl & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

BareDecl::~BareDecl()
{
  delete(type_);

}

void BareDecl::accept(Visitor *v)
{
  v->visitBareDecl(this);
}

BareDecl *BareDecl::clone() const
{
  return new BareDecl(*this);
}



/********************   EFuncDecl    ********************/
EFuncDecl::EFuncDecl(Ident p1, ListArgument *p2, StatementBlock *p3)
{
  ident_ = p1;
  listargument_ = p2;
  statementblock_ = p3;

}

EFuncDecl::EFuncDecl(const EFuncDecl & other)
{
  ident_ = other.ident_;
  listargument_ = other.listargument_->clone();
  statementblock_ = other.statementblock_->clone();

}

EFuncDecl &EFuncDecl::operator=(const EFuncDecl & other)
{
  EFuncDecl tmp(other);
  swap(tmp);
  return *this;
}

void EFuncDecl::swap(EFuncDecl & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listargument_, other.listargument_);
  std::swap(statementblock_, other.statementblock_);

}

EFuncDecl::~EFuncDecl()
{
  delete(listargument_);
  delete(statementblock_);

}

void EFuncDecl::accept(Visitor *v)
{
  v->visitEFuncDecl(this);
}

EFuncDecl *EFuncDecl::clone() const
{
  return new EFuncDecl(*this);
}



/********************   EFuncDeclWithType    ********************/
EFuncDeclWithType::EFuncDeclWithType(Type *p1, Ident p2, ListArgument *p3, StatementBlock *p4)
{
  type_ = p1;
  ident_ = p2;
  listargument_ = p3;
  statementblock_ = p4;

}

EFuncDeclWithType::EFuncDeclWithType(const EFuncDeclWithType & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listargument_ = other.listargument_->clone();
  statementblock_ = other.statementblock_->clone();

}

EFuncDeclWithType &EFuncDeclWithType::operator=(const EFuncDeclWithType & other)
{
  EFuncDeclWithType tmp(other);
  swap(tmp);
  return *this;
}

void EFuncDeclWithType::swap(EFuncDeclWithType & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listargument_, other.listargument_);
  std::swap(statementblock_, other.statementblock_);

}

EFuncDeclWithType::~EFuncDeclWithType()
{
  delete(type_);
  delete(listargument_);
  delete(statementblock_);

}

void EFuncDeclWithType::accept(Visitor *v)
{
  v->visitEFuncDeclWithType(this);
}

EFuncDeclWithType *EFuncDeclWithType::clone() const
{
  return new EFuncDeclWithType(*this);
}



/********************   ElseIfBlock    ********************/
ElseIfBlock::ElseIfBlock(Exp *p1, StatementBlock *p2)
{
  exp_ = p1;
  statementblock_ = p2;

}

ElseIfBlock::ElseIfBlock(const ElseIfBlock & other)
{
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();

}

ElseIfBlock &ElseIfBlock::operator=(const ElseIfBlock & other)
{
  ElseIfBlock tmp(other);
  swap(tmp);
  return *this;
}

void ElseIfBlock::swap(ElseIfBlock & other)
{
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);

}

ElseIfBlock::~ElseIfBlock()
{
  delete(exp_);
  delete(statementblock_);

}

void ElseIfBlock::accept(Visitor *v)
{
  v->visitElseIfBlock(this);
}

ElseIfBlock *ElseIfBlock::clone() const
{
  return new ElseIfBlock(*this);
}



/********************   ElseIf2Block    ********************/
ElseIf2Block::ElseIf2Block(Exp *p1, StatementBlock *p2, ElseBlock *p3)
{
  exp_ = p1;
  statementblock_ = p2;
  elseblock_ = p3;

}

ElseIf2Block::ElseIf2Block(const ElseIf2Block & other)
{
  exp_ = other.exp_->clone();
  statementblock_ = other.statementblock_->clone();
  elseblock_ = other.elseblock_->clone();

}

ElseIf2Block &ElseIf2Block::operator=(const ElseIf2Block & other)
{
  ElseIf2Block tmp(other);
  swap(tmp);
  return *this;
}

void ElseIf2Block::swap(ElseIf2Block & other)
{
  std::swap(exp_, other.exp_);
  std::swap(statementblock_, other.statementblock_);
  std::swap(elseblock_, other.elseblock_);

}

ElseIf2Block::~ElseIf2Block()
{
  delete(exp_);
  delete(statementblock_);
  delete(elseblock_);

}

void ElseIf2Block::accept(Visitor *v)
{
  v->visitElseIf2Block(this);
}

ElseIf2Block *ElseIf2Block::clone() const
{
  return new ElseIf2Block(*this);
}



/********************   ElseBlockStat    ********************/
ElseBlockStat::ElseBlockStat(StatementBlock *p1)
{
  statementblock_ = p1;

}

ElseBlockStat::ElseBlockStat(const ElseBlockStat & other)
{
  statementblock_ = other.statementblock_->clone();

}

ElseBlockStat &ElseBlockStat::operator=(const ElseBlockStat & other)
{
  ElseBlockStat tmp(other);
  swap(tmp);
  return *this;
}

void ElseBlockStat::swap(ElseBlockStat & other)
{
  std::swap(statementblock_, other.statementblock_);

}

ElseBlockStat::~ElseBlockStat()
{
  delete(statementblock_);

}

void ElseBlockStat::accept(Visitor *v)
{
  v->visitElseBlockStat(this);
}

ElseBlockStat *ElseBlockStat::clone() const
{
  return new ElseBlockStat(*this);
}



/********************   ElseFailStat    ********************/
ElseFailStat::ElseFailStat()
{

}

ElseFailStat::ElseFailStat(const ElseFailStat & other)
{

}

ElseFailStat &ElseFailStat::operator=(const ElseFailStat & other)
{
  ElseFailStat tmp(other);
  swap(tmp);
  return *this;
}

void ElseFailStat::swap(ElseFailStat & other)
{

}

ElseFailStat::~ElseFailStat()
{

}

void ElseFailStat::accept(Visitor *v)
{
  v->visitElseFailStat(this);
}

ElseFailStat *ElseFailStat::clone() const
{
  return new ElseFailStat(*this);
}



/********************   EOr    ********************/
EOr::EOr(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EOr::EOr(const EOr & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EOr::~EOr()
{
  delete(exp_1);
  delete(exp_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EEquals    ********************/
EEquals::EEquals(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EEquals::EEquals(const EEquals & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EEquals &EEquals::operator=(const EEquals & other)
{
  EEquals tmp(other);
  swap(tmp);
  return *this;
}

void EEquals::swap(EEquals & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EEquals::~EEquals()
{
  delete(exp_1);
  delete(exp_2);

}

void EEquals::accept(Visitor *v)
{
  v->visitEEquals(this);
}

EEquals *EEquals::clone() const
{
  return new EEquals(*this);
}



/********************   ENEq    ********************/
ENEq::ENEq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ENEq::ENEq(const ENEq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ENEq &ENEq::operator=(const ENEq & other)
{
  ENEq tmp(other);
  swap(tmp);
  return *this;
}

void ENEq::swap(ENEq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ENEq::~ENEq()
{
  delete(exp_1);
  delete(exp_2);

}

void ENEq::accept(Visitor *v)
{
  v->visitENEq(this);
}

ENEq *ENEq::clone() const
{
  return new ENEq(*this);
}



/********************   ELeq    ********************/
ELeq::ELeq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELeq::ELeq(const ELeq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELeq &ELeq::operator=(const ELeq & other)
{
  ELeq tmp(other);
  swap(tmp);
  return *this;
}

void ELeq::swap(ELeq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELeq::~ELeq()
{
  delete(exp_1);
  delete(exp_2);

}

void ELeq::accept(Visitor *v)
{
  v->visitELeq(this);
}

ELeq *ELeq::clone() const
{
  return new ELeq(*this);
}



/********************   EGeq    ********************/
EGeq::EGeq(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGeq::EGeq(const EGeq & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGeq &EGeq::operator=(const EGeq & other)
{
  EGeq tmp(other);
  swap(tmp);
  return *this;
}

void EGeq::swap(EGeq & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGeq::~EGeq()
{
  delete(exp_1);
  delete(exp_2);

}

void EGeq::accept(Visitor *v)
{
  v->visitEGeq(this);
}

EGeq *EGeq::clone() const
{
  return new EGeq(*this);
}



/********************   ELessThan    ********************/
ELessThan::ELessThan(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ELessThan::ELessThan(const ELessThan & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ELessThan &ELessThan::operator=(const ELessThan & other)
{
  ELessThan tmp(other);
  swap(tmp);
  return *this;
}

void ELessThan::swap(ELessThan & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ELessThan::~ELessThan()
{
  delete(exp_1);
  delete(exp_2);

}

void ELessThan::accept(Visitor *v)
{
  v->visitELessThan(this);
}

ELessThan *ELessThan::clone() const
{
  return new ELessThan(*this);
}



/********************   EGreaterThan    ********************/
EGreaterThan::EGreaterThan(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EGreaterThan::EGreaterThan(const EGreaterThan & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EGreaterThan &EGreaterThan::operator=(const EGreaterThan & other)
{
  EGreaterThan tmp(other);
  swap(tmp);
  return *this;
}

void EGreaterThan::swap(EGreaterThan & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EGreaterThan::~EGreaterThan()
{
  delete(exp_1);
  delete(exp_2);

}

void EGreaterThan::accept(Visitor *v)
{
  v->visitEGreaterThan(this);
}

EGreaterThan *EGreaterThan::clone() const
{
  return new EGreaterThan(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   ENot    ********************/
ENot::ENot(Exp *p1)
{
  exp_ = p1;

}

ENot::ENot(const ENot & other)
{
  exp_ = other.exp_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(exp_, other.exp_);

}

ENot::~ENot()
{
  delete(exp_);

}

void ENot::accept(Visitor *v)
{
  v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}



/********************   EIdent    ********************/
EIdent::EIdent(Ident p1)
{
  ident_ = p1;

}

EIdent::EIdent(const EIdent & other)
{
  ident_ = other.ident_;

}

EIdent &EIdent::operator=(const EIdent & other)
{
  EIdent tmp(other);
  swap(tmp);
  return *this;
}

void EIdent::swap(EIdent & other)
{
  std::swap(ident_, other.ident_);

}

EIdent::~EIdent()
{

}

void EIdent::accept(Visitor *v)
{
  v->visitEIdent(this);
}

EIdent *EIdent::clone() const
{
  return new EIdent(*this);
}



/********************   EVector    ********************/
EVector::EVector(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

EVector::EVector(const EVector & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

EVector &EVector::operator=(const EVector & other)
{
  EVector tmp(other);
  swap(tmp);
  return *this;
}

void EVector::swap(EVector & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

EVector::~EVector()
{
  delete(listexp_);

}

void EVector::accept(Visitor *v)
{
  v->visitEVector(this);
}

EVector *EVector::clone() const
{
  return new EVector(*this);
}



/********************   EFuncCall    ********************/
EFuncCall::EFuncCall(Ident p1, ListExp *p2)
{
  ident_ = p1;
  listexp_ = p2;

}

EFuncCall::EFuncCall(const EFuncCall & other)
{
  ident_ = other.ident_;
  listexp_ = other.listexp_->clone();

}

EFuncCall &EFuncCall::operator=(const EFuncCall & other)
{
  EFuncCall tmp(other);
  swap(tmp);
  return *this;
}

void EFuncCall::swap(EFuncCall & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexp_, other.listexp_);

}

EFuncCall::~EFuncCall()
{
  delete(listexp_);

}

void EFuncCall::accept(Visitor *v)
{
  v->visitEFuncCall(this);
}

EFuncCall *EFuncCall::clone() const
{
  return new EFuncCall(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EFloat    ********************/
EFloat::EFloat(Double p1)
{
  double_ = p1;

}

EFloat::EFloat(const EFloat & other)
{
  double_ = other.double_;

}

EFloat &EFloat::operator=(const EFloat & other)
{
  EFloat tmp(other);
  swap(tmp);
  return *this;
}

void EFloat::swap(EFloat & other)
{
  std::swap(double_, other.double_);

}

EFloat::~EFloat()
{

}

void EFloat::accept(Visitor *v)
{
  v->visitEFloat(this);
}

EFloat *EFloat::clone() const
{
  return new EFloat(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   ArgumentDef    ********************/
ArgumentDef::ArgumentDef(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

ArgumentDef::ArgumentDef(const ArgumentDef & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

ArgumentDef &ArgumentDef::operator=(const ArgumentDef & other)
{
  ArgumentDef tmp(other);
  swap(tmp);
  return *this;
}

void ArgumentDef::swap(ArgumentDef & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

ArgumentDef::~ArgumentDef()
{
  delete(type_);

}

void ArgumentDef::accept(Visitor *v)
{
  v->visitArgumentDef(this);
}

ArgumentDef *ArgumentDef::clone() const
{
  return new ArgumentDef(*this);
}



/********************   EType    ********************/
EType::EType(Ident p1)
{
  ident_ = p1;

}

EType::EType(const EType & other)
{
  ident_ = other.ident_;

}

EType &EType::operator=(const EType & other)
{
  EType tmp(other);
  swap(tmp);
  return *this;
}

void EType::swap(EType & other)
{
  std::swap(ident_, other.ident_);

}

EType::~EType()
{

}

void EType::accept(Visitor *v)
{
  v->visitEType(this);
}

EType *EType::clone() const
{
  return new EType(*this);
}



/********************   VectorType    ********************/
VectorType::VectorType(Type *p1, Type *p2)
{
  type_1 = p1;
  type_2 = p2;

}

VectorType::VectorType(const VectorType & other)
{
  type_1 = other.type_1->clone();
  type_2 = other.type_2->clone();

}

VectorType &VectorType::operator=(const VectorType & other)
{
  VectorType tmp(other);
  swap(tmp);
  return *this;
}

void VectorType::swap(VectorType & other)
{
  std::swap(type_1, other.type_1);
  std::swap(type_2, other.type_2);

}

VectorType::~VectorType()
{
  delete(type_1);
  delete(type_2);

}

void VectorType::accept(Visitor *v)
{
  v->visitVectorType(this);
}

VectorType *VectorType::clone() const
{
  return new VectorType(*this);
}



/********************   RangeType    ********************/
RangeType::RangeType(Integer p1, Integer p2)
{
  integer_1 = p1;
  integer_2 = p2;

}

RangeType::RangeType(const RangeType & other)
{
  integer_1 = other.integer_1;
  integer_2 = other.integer_2;

}

RangeType &RangeType::operator=(const RangeType & other)
{
  RangeType tmp(other);
  swap(tmp);
  return *this;
}

void RangeType::swap(RangeType & other)
{
  std::swap(integer_1, other.integer_1);
  std::swap(integer_2, other.integer_2);

}

RangeType::~RangeType()
{

}

void RangeType::accept(Visitor *v)
{
  v->visitRangeType(this);
}

RangeType *RangeType::clone() const
{
  return new RangeType(*this);
}



/********************   SetType    ********************/
SetType::SetType(ListSetTypeElem *p1)
{
  listsettypeelem_ = p1;

}

SetType::SetType(const SetType & other)
{
  listsettypeelem_ = other.listsettypeelem_->clone();

}

SetType &SetType::operator=(const SetType & other)
{
  SetType tmp(other);
  swap(tmp);
  return *this;
}

void SetType::swap(SetType & other)
{
  std::swap(listsettypeelem_, other.listsettypeelem_);

}

SetType::~SetType()
{
  delete(listsettypeelem_);

}

void SetType::accept(Visitor *v)
{
  v->visitSetType(this);
}

SetType *SetType::clone() const
{
  return new SetType(*this);
}



/********************   EIntSTE    ********************/
EIntSTE::EIntSTE(Integer p1)
{
  integer_ = p1;

}

EIntSTE::EIntSTE(const EIntSTE & other)
{
  integer_ = other.integer_;

}

EIntSTE &EIntSTE::operator=(const EIntSTE & other)
{
  EIntSTE tmp(other);
  swap(tmp);
  return *this;
}

void EIntSTE::swap(EIntSTE & other)
{
  std::swap(integer_, other.integer_);

}

EIntSTE::~EIntSTE()
{

}

void EIntSTE::accept(Visitor *v)
{
  v->visitEIntSTE(this);
}

EIntSTE *EIntSTE::clone() const
{
  return new EIntSTE(*this);
}



/********************   EFloatSTE    ********************/
EFloatSTE::EFloatSTE(Double p1)
{
  double_ = p1;

}

EFloatSTE::EFloatSTE(const EFloatSTE & other)
{
  double_ = other.double_;

}

EFloatSTE &EFloatSTE::operator=(const EFloatSTE & other)
{
  EFloatSTE tmp(other);
  swap(tmp);
  return *this;
}

void EFloatSTE::swap(EFloatSTE & other)
{
  std::swap(double_, other.double_);

}

EFloatSTE::~EFloatSTE()
{

}

void EFloatSTE::accept(Visitor *v)
{
  v->visitEFloatSTE(this);
}

EFloatSTE *EFloatSTE::clone() const
{
  return new EFloatSTE(*this);
}



/********************   EStringSTE    ********************/
EStringSTE::EStringSTE(String p1)
{
  string_ = p1;

}

EStringSTE::EStringSTE(const EStringSTE & other)
{
  string_ = other.string_;

}

EStringSTE &EStringSTE::operator=(const EStringSTE & other)
{
  EStringSTE tmp(other);
  swap(tmp);
  return *this;
}

void EStringSTE::swap(EStringSTE & other)
{
  std::swap(string_, other.string_);

}

EStringSTE::~EStringSTE()
{

}

void EStringSTE::accept(Visitor *v)
{
  v->visitEStringSTE(this);
}

EStringSTE *EStringSTE::clone() const
{
  return new EStringSTE(*this);
}




/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}


ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}


/********************   ListArgument    ********************/

void ListArgument::accept(Visitor *v)
{
  v->visitListArgument(this);
}


ListArgument *ListArgument::clone() const
{
  return new ListArgument(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListSetTypeElem    ********************/

void ListSetTypeElem::accept(Visitor *v)
{
  v->visitListSetTypeElem(this);
}


ListSetTypeElem *ListSetTypeElem::clone() const
{
  return new ListSetTypeElem(*this);
}



